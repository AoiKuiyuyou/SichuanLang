过场 双调排序（列表）
    列表长度搁列表嘞长度
    如果列表长度小于等于一
        爬开列表
    就弄个
    列表长度二的幂搁一比特左移列表长度咧bit_length（）
    长度差搁列表长度二的幂减列表长度
    如果长度差不等于零
        最大值搁列表嘞最大值
        甲索引搁零
        莽起整要是甲索引小于长度差
            列表嘞后加（最大值）
            甲索引加滴点儿
        就弄个
    就弄个
    双调排序范围（列表，零，列表长度二的幂，真嘞）
    如果长度差不等于零
        甲索引搁零
        莽起整要是甲索引小于长度差
            列表咧pop（）
            甲索引加滴点儿
        就弄个
    就弄个
    爬开列表
过场多


过场 双调排序范围（列表，低索引，个数，升序吗）
    如果个数小于等于一
        爬开
    就弄个
    半数搁个数整除二
    双调排序范围（列表，低索引，半数，真嘞）
    双调排序范围（列表，低索引加半数，半数，假嘞）
    双调合并（列表，低索引，个数，升序吗）
过场多


过场 双调合并（列表，低索引，个数，升序吗）
    如果个数小于等于一
        爬开
    就弄个
    半数搁个数整除二
    挨倒把（低索引，低索引加半数）嘞范围内每项给当前索引弄个整
        比较交换（列表，当前索引，当前索引加半数，升序吗）
    就弄个
    双调合并（列表，低索引，半数，升序吗）
    双调合并（列表，低索引加半数，半数，升序吗）
过场多


过场 比较交换（列表，甲索引，乙索引，升序吗）
    如果（升序吗就是真嘞并且列表第甲索引项大于列表第乙索引项）
    或者（升序吗就是假嘞并且列表第甲索引项小于列表第乙索引项）
        列表第甲索引项，列表第乙索引项
        搁
        列表第乙索引项，列表第甲索引项
    就弄个
过场多
