# Generate the parser:
# ```
# aoiktopdownparser -r SichuanLang/src/sichuanlang/parser_rules.txt -t SichuanLang/src/sichuanlang/parser_tplt.py -o SichuanLang/src/sichuanlang/parser.py
# ```
#
#
# We use custom lexer instead of the one automatically generated by the parser
# generator so the regex patterns for terminal tokens defined in this rules
# file are unused during actual parsing, only the token names matter. However,
# the parser generator will use these regex patterns to compute first set and
# follow set, so we must keep these regex patterns unique to each other.


source_code:
    `start_row, start_col = self._get_start_row_col()`
    stmts
    ```
    end_row, end_col = self._get_end_row_col()
    ctx.res = Module(
        stmts.res,
        type_ignores=[],
        lineno=start_row,
        col_offset=start_col,
        end_lineno=end_row,
        end_col_offset=end_col,
    )
    ```
    end


end: '$'


comma_hz: '，'


pause_hz: '、'


colon_hz: '：'


semicolon_hz: '；'


period_hz: '。'


question_mark_hz: '？'


left_parenthesis_hz: '（'


right_parenthesis_hz: '）'


none_kw: '虚嘞'


bool_true_kw: '真嘞'


bool_false_kw: '假嘞'


list_kw: '箱箱'


list_with_kw: '箱箱装'


tuple_kw: '包包'


tuple_with_kw: '包包装'


dict_kw: '盒盒'


dict_with_kw: '盒盒装'


set_kw: '袋袋'


set_with_kw: '袋袋装'


assign_op: '搁'


global_kw: '在外头'


nonlocal_kw: '在上头'


not_op: '并非'


or_op: '或者'


and_op: '并且'


is_op: '就是'


isnot_op: '不是'


equal_op: '等于'


not_equal_op: '不等于'


lt_op: '小于'


le_op: '小于等于'


gt_op: '大于'


ge_op: '大于等于'


in_op: '存在于'


not_in_op: '不存在于'


arrow_op: '接倒起'


bit_and_op: '比特与'


bit_and_assign_op: '比特与搁'


bit_or_op: '比特或'


bit_or_assign_op: '比特或搁'


bit_xor_op: '比特异或'


bit_xor_assign_op: '比特异或搁'


bit_left_shift_op: '比特左移'


bit_left_shift_assign_op: '比特左移搁'


bit_right_shift_op: '比特右移'


bit_right_shift_assign_op: '比特右移搁'


bit_invert_op: '比特反转'


bit_invert_assign_op: '比特反转搁'


increment_op: '加滴点儿'


decrement_op: '减滴点儿'


add_op: '加'


add_assign_op: '加搁'


subtract_op: '减'


subtract_assign_op: '减搁'


multiply_op: '乘'


multiply_assign_op: '乘搁'


divide_op: '除'


divide_assign_op: '除搁'


floor_divide_op: '整除'


floor_divide_assign_op: '整除搁'


modulo_op: '算余数'


modulo_assign_op: '算余数搁'


power_op: '算指数'


power_assign_op: '算指数搁'


unary_subtract_op: '负'


dot_kw: '咧'


subscript_start_kw: '第'


subscript_end_kw: '项'


comp_item_as_name_kw: '每项交给'


async_comp_item_as_name_kw: '每项慢慢交给'


comp_if_kw: '要是'


comp_then_kw: '然后'


listcomp_generate_kw: '生成'


generator_generate_kw: '慢慢生成'


if_kw: '如果'


elif_kw: '又如果'


else_kw: '要不然'


block_start_kw: '弄个整'


block_end_kw: '就弄个'


loop_always_kw: '莽起整'


loop_if_kw: '莽起整要是'


loop_until_kw: '莽起整直到'


loop_iterator_kw: '挨倒把'


async_loop_iterator_kw: '挨倒慢慢把'


loop_iterator_item_as_name_kw: '每项给'


continue_kw: '接倒整'


break_kw: '不整了'


try_kw: '试一哈'


except_kw: '抓一哈'


finally_kw: '最后才'


raise_kw: '放飞'


raise_from_kw: '带起'


with_kw: '用一哈'


async_with_kw: '慢慢用一哈'


yield_kw: '让一哈'


yield_from_kw: '让一哈哈儿'


await_kw: '等一哈'


func_start_kw: '过场'


async_func_start_kw: '过场慢'


func_end_kw: '过场多'


collect_args_kw: '收拢'


collect_kwargs_kw: '收拢来'


expand_args_kw: '展开'


expand_kwargs_kw: '展开来'


class_start_kw: '名堂'


class_end_kw: '名堂多'


decorate_kw: '打整一哈'


pass_kw: '搞空名堂'


del_kw: '丢翻'


return_kw: '爬开'


assert_kw: '硬是要'


print_kw: '开腔'


exit_kw: '哦嚯'


import_kw: '来给我扎起'


from_import_kw: '出来给我扎起'


as_kw: '叫做'


trailer_prefix: '嘞'


type_trailer: '嘞名堂'


bool_trailer: '嘞真假'


int_trailer: '嘞整数'


float_trailer: '嘞浮点数'


str_trailer: '嘞字符串'


repr_trailer: '嘞表示'


bytes_trailer: '嘞字节串'


bytearray_trailer: '嘞字节数组'


chr_trailer: '嘞字符'


ord_trailer: '嘞字符序数'


hex_trailer: '嘞十六进制'


oct_trailer: '嘞八进制'


bin_trailer: '嘞二进制'


list_trailer: '嘞箱箱'


tuple_trailer: '嘞包包'


dict_trailer: '嘞盒盒'


set_trailer: '嘞袋袋'


len_trailer: '嘞长度'


count_trailer: '嘞总数'


abs_trailer: '嘞绝对值'


min_trailer: '嘞最小值'


max_trailer: '嘞最大值'


opposite_trailer: '嘞相反数'


reciprocal_trailer: '嘞倒数'


sum_trailer: '嘞和'


any_trailer: '嘞任意为真'


all_trailer: '嘞全部为真'


range_trailer: '嘞范围内'


name_trailer: '嘞名字'


format_trailer: '嘞格式化'


add_trailer: '嘞添加'


append_trailer: '嘞后加'


extend_trailer: '嘞后加每项'


clear_trailer: '嘞清空'


sort_trailer: '嘞排序'


none:
    ```
    token_index = self._get_token_index()
    start_row, start_col = self._get_start_row_col()
    ```
    none_kw
    ```
    end_row, end_col = self._get_end_row_col()
    ctx.res = NameConstant(
        None,
        kind=None,
        lineno=start_row,
        col_offset=start_col,
        end_lineno=end_row,
        end_col_offset=end_col,
    )
    ctx.res.token_index = token_index
    ```


boolean:
    ```
    token_index = self._get_token_index()
    start_row, start_col = self._get_start_row_col()
    ```
    (
    bool_true_kw
    `value = True`
    |
    bool_false_kw
    `value = False`
    )
    ```
    end_row, end_col = self._get_end_row_col()
    ctx.res = NameConstant(
        value,
        kind=None,
        lineno=start_row,
        col_offset=start_col,
        end_lineno=end_row,
        end_col_offset=end_col,
    )
    ctx.res.token_index = token_index
    ```


number:
    ```
    token_index = self._get_token_index()
    start_row, start_col = self._get_start_row_col()
    ```
    'number'
    ```
    end_row, end_col = self._get_end_row_col()

    if number.res.txt[0] in HANZI_DIGITS_AND_UNITS:
        value = hanzi_digits_to_value(number.res.txt)
    else:
        number_text = number.res.txt.replace('_', '')

        value = eval(number_text)

    ctx.res = Num(
        value,
        kind=None,
        lineno=start_row,
        col_offset=start_col,
        end_lineno=end_row,
        end_col_offset=end_col,
    )
    ctx.res.token_index = token_index
    ```


string:
    ```
    token_index = self._get_token_index()
    start_row, start_col = self._get_start_row_col()
    ```
    'string'
    ```
    end_row, end_col = self._get_end_row_col()
    ctx.res = Str(
        string.res.value,
        kind=None,
        lineno=start_row,
        col_offset=start_col,
        end_lineno=end_row,
        end_col_offset=end_col,
    )
    ctx.res.token_index = token_index
    ```


name:
    ```
    token_index = self._get_token_index()
    start_row, start_col = self._get_start_row_col()
    ```
    'name'
    ```
    end_row, end_col = self._get_end_row_col()
    ctx.res = Name(
        id=name.res.txt,
        ctx=Load(),
        lineno=start_row,
        col_offset=start_col,
        end_lineno=end_row,
        end_col_offset=end_col,
    )
    ctx.res.token_index = token_index
    ```


stmts:
    `stmts = []`
    (
        stmt
        `stmts.append(stmt.res)`
        (semicolon_hz|period_hz)?
    )*
    `ctx.res = stmts`


stmt:
    simple_stmt
    `ctx.res = simple_stmt.res`
    |
    compound_stmt
    `ctx.res = compound_stmt.res`


simple_stmt:
    `start_row, start_col = self._get_start_row_col()`
    (
        pass_stmt
        `node = pass_stmt.res`
        |
        del_stmt
        `node = del_stmt.res`
        |
        continue_stmt
        `node = continue_stmt.res`
        |
        break_stmt
        `node = break_stmt.res`
        |
        return_stmt
        `node = return_stmt.res`
        |
        raise_stmt
        `node = raise_stmt.res`
        |
        assert_stmt
        `node = assert_stmt.res`
        |
        exit_stmt
        `node = exit_stmt.res`
        |
        print_stmt
        `node = print_stmt.res`
        |
        yield_expr
        `node = yield_expr.res`
        |
        expr_or_assign_stmt
        `node = expr_or_assign_stmt.res`
    )
    ```
    if isinstance(node, ExprBase)\
    and node.__class__ is not Expr:
        end_row, end_col = self._get_end_row_col()

        node = Expr(
            node,
            lineno=start_row,
            col_offset=start_col,
            end_lineno=end_row,
            end_col_offset=end_col,
        )

    ctx.res = node
    ```


pass_stmt:
    `start_row, start_col = self._get_start_row_col()`
    pass_kw
    ```
    end_row, end_col = self._get_end_row_col()
    ctx.res = Pass(
        lineno=start_row,
        col_offset=start_col,
        end_lineno=end_row,
        end_col_offset=end_col,
    )
    ```


del_stmt:
    `start_row, start_col = self._get_start_row_col()`
    del_kw
    name
    ```
    end_row, end_col = self._get_end_row_col()
    name_node = name.res
    name_node.ctx = Del()
    ctx.res = Delete(
        targets=[name_node],
        lineno=start_row,
        col_offset=start_col,
        end_lineno=end_row,
        end_col_offset=end_col,
    )
    ```


continue_stmt:
    `start_row, start_col = self._get_start_row_col()`
    continue_kw
    ```
    end_row, end_col = self._get_end_row_col()
    ctx.res = Continue(
        lineno=start_row,
        col_offset=start_col,
        end_lineno=end_row,
        end_col_offset=end_col,
    )
    ```


break_stmt:
    `start_row, start_col = self._get_start_row_col()`
    break_kw
    ```
    end_row, end_col = self._get_end_row_col()
    ctx.res = Break(
        lineno=start_row,
        col_offset=start_col,
        end_lineno=end_row,
        end_col_offset=end_col,
    )
    ```


return_stmt:
    `start_row, start_col = self._get_start_row_col()`
    return_kw
    `value = None`
    (
        expr
        `value = expr.res`
    )?
    ```
    end_row, end_col = self._get_end_row_col()
    ctx.res = Return(
        value=value,
        lineno=start_row,
        col_offset=start_col,
        end_lineno=end_row,
        end_col_offset=end_col,
    )
    ```


raise_stmt:
    `start_row, start_col = self._get_start_row_col()`
    raise_kw
    ```
    exc_expr = None
    cause_expr = None
    ```
    (
        expr
        ```
        exc_expr = expr.res
        ```
        (
            raise_from_kw
            expr
            `cause_expr = expr.res`
        )?
    )?
    ```
    end_row, end_col = self._get_end_row_col()

    ctx.res = Raise(
        exc=exc_expr,
        cause=cause_expr,
        lineno=start_row,
        col_offset=start_col,
        end_lineno=end_row,
        end_col_offset=end_col,
    )
    ```


assert_stmt:
    `start_row, start_col = self._get_start_row_col()`
    assert_kw
    expr
    ```
    test_expr = expr.res
    msg_expr = None
    ```
    (
        comma_hz
        expr
        `msg_expr = expr.res`
    )?
    ```
    end_row, end_col = self._get_end_row_col()
    ctx.res = Assert(
        test=test_expr,
        msg=msg_expr,
        lineno=start_row,
        col_offset=start_col,
        end_lineno=end_row,
        end_col_offset=end_col,
    )
    ```


exit_stmt:
    `start_row, start_col = self._get_start_row_col()`
    exit_kw
    ```
    kw_end_row, kw_end_col = self._get_end_row_col()
    expr_node = None
    ```
    (
    expr
    `expr_node = expr.res`
    )?
    ```
    end_row, end_col = self._get_end_row_col()

    if expr_node is None:
        expr_node = NameConstant(
            value=None,
            kind=None,
            lineno=end_row,
            col_offset=end_col,
            end_lineno=end_row,
            end_col_offset=end_col,
        )

    ctx.res = Expr(
        value=Call(
            func=Name(
                id='exit',
                ctx=Load(),
                lineno=start_row,
                col_offset=start_col,
                end_lineno=kw_end_row,
                end_col_offset=kw_end_col,
            ),
            args=[expr_node],
            keywords=[],
            lineno=start_row,
            col_offset=start_col,
            end_lineno=end_row,
            end_col_offset=end_col,
        ),
        lineno=start_row,
        col_offset=start_col,
        end_lineno=end_row,
        end_col_offset=end_col,
    )
    ```


print_stmt:
    `start_row, start_col = self._get_start_row_col()`
    print_kw
    ```
    end_row, end_col = self._get_end_row_col()
    func_name_node = Name(
        id='print',
        ctx=Load(),
        lineno=start_row,
        col_offset=start_col,
        end_lineno=end_row,
        end_col_offset=end_col,
    )
    ```
    args_list
    ```
    end_row, end_col = self._get_end_row_col()
    ctx.res = Expr(
        value=Call(
            func=func_name_node,
            args=args_list.res.args,
            keywords=args_list.res.kwargs,
            lineno=start_row,
            col_offset=start_col,
            end_lineno=end_row,
            end_col_offset=end_col,
        ),
        lineno=start_row,
        col_offset=start_col,
        end_lineno=end_row,
        end_col_offset=end_col,
    )
    ```
    |
    `start_row, start_col = self._get_start_row_col()`
    await_kw
    expr
    ```
    end_row, end_col = self._get_end_row_col()
    ctx.res = Await(expr.res)
    ```


args_list:
    ```
    # Used in child `args_list_item`.
    ctx.res = AttrDict()
    ctx.res.args = []
    ctx.res.kwargs = []
    ctx.res.expand_args_node = None
    ctx.res.expand_kwargs_node = None
    ```
    left_parenthesis_hz
    (
        right_parenthesis_hz
        |
        args_list_item
    )


args_list_item:
    ```
    # Used in child `args_list_item`.
    ctx.res = ctx.par.res
    expand_mode = None
    start_row, start_col =\
        self._get_start_row_col()
    ```
    (
        expand_args_kw
        ```
        if ctx.res.expand_args_node is not None:
            self._retract()
            self._error(msg='`展开`不能用第二次。')

        if ctx.res.expand_kwargs_node is not None:
            self._retract()
            self._error(msg='`展开`不能在`展开来`之后。')

        expand_mode = 1
        ```
        |
        expand_kwargs_kw
        ```
        if ctx.res.expand_kwargs_node is not None:
            self._retract()
            self._error(msg='`展开来`不能用第二次。')

        expand_mode = 2
        ```
    )?
    `lhs_expr_token_index = self._get_token_index()`
    cond_expr
    ```
    lhs_expr = cond_expr.res
    rhs_expr = None
    ```
    (
        assign_op
        ```
        if expand_mode == 1:
            self._retract()
            self._error(msg='`展开`参数不能有默认值。')
        elif expand_mode == 2:
            self._retract()
            self._error(msg='`展开来`参数不能有默认值。')
        elif not isinstance(lhs_expr, Name):
            self._retract(lhs_expr_token_index)
            self._error(msg='不是合格的参数名。')
        ```
        cond_expr
        `rhs_expr = cond_expr.res`
    )?
    ```
    end_row, end_col = self._get_end_row_col()
    if expand_mode == 1:
        node = Starred(
            value=cond_expr.res,
            ctx=Load(),
            lineno=start_row,
            col_offset=start_col,
            end_lineno=end_row,
            end_col_offset=end_col,
        )
        ctx.res.expand_args_node = node
        ctx.res.args.append(node)
    elif expand_mode == 2:
        node = keyword(
            arg=None,
            value=cond_expr.res,
            lineno=start_row,
            col_offset=start_col,
            end_lineno=end_row,
            end_col_offset=end_col,
        )
        ctx.res.expand_kwargs_node = node
        ctx.res.kwargs.append(node)
    elif rhs_expr is not None:
        node = keyword(
            arg=lhs_expr.id,
            value=rhs_expr,
            lineno=start_row,
            col_offset=start_col,
            end_lineno=end_row,
            end_col_offset=end_col,
        )
        ctx.res.kwargs.append(node)
    else:
        if ctx.res.kwargs:
            self._retract(lhs_expr_token_index)
            self._error(msg='排位参数不能出现在关键字参数之后。')
        node = cond_expr.res
        ctx.res.args.append(node)
    ```
    (
        right_parenthesis_hz
        |
        comma_hz
        (
            right_parenthesis_hz
            |
            args_list_item
        )
    )


yield_expr:
    ```
    token_index = self._get_token_index()
    start_row, start_col = self._get_start_row_col()
    ```
    (
        yield_kw
        `expr_node = None`
        (
            expr
            `expr_node = expr.res`
        )?
        ```
        end_row, end_col = self._get_end_row_col()
        ctx.res = Yield(
            expr_node,
            lineno=start_row,
            col_offset=start_col,
            end_lineno=end_row,
            end_col_offset=end_col,
        )
        ```
        |
        yield_from_kw
        expr
        ```
        end_row, end_col = self._get_end_row_col()
        ctx.res = YieldFrom(
            expr.res,
            lineno=start_row,
            col_offset=start_col,
            end_lineno=end_row,
            end_col_offset=end_col,
        )
        ```
    )
    `ctx.res.token_index = token_index`


expr_or_assign_stmt:
    `start_row, start_col = self._get_start_row_col()`
    expr
    `res_node = expr.res`
    (
        assign_op
        expr
        ```
        end_row, end_col = self._get_end_row_col()
        self._set_store_ctx(res_node)
        res_node = Assign(
            targets=[res_node],
            value=expr.res,
            lineno=start_row,
            col_offset=start_col,
            end_lineno=end_row,
            end_col_offset=end_col,
        )
        ```
        |
        (
            increment_op
            `add_value = 1`
            |
            decrement_op
            `add_value = -1`
        )
        ```
        end_row, end_col = self._get_end_row_col()
        self._set_store_ctx(res_node)
        res_node = AugAssign(
            target=res_node,
            op=Add(),
            value=Num(
                add_value,
                kind=None,
                lineno=start_row,
                col_offset=start_col,
                end_lineno=end_row,
                end_col_offset=end_col,
            ),
            lineno=start_row,
            col_offset=start_col,
            end_lineno=end_row,
            end_col_offset=end_col,
        )
        ```
        |
        (
            import_kw
            `is_from_import = False`
            |
            `from_import_token_index = self._get_token_index()`
            from_import_kw
            `is_from_import = True`
        )
        ```
        end_row, end_col = self._get_end_row_col()

        if isinstance(res_node, Name):
            module_name = res_node.id
        elif isinstance(res_node, Attribute):
            stack = []

            attr_node = res_node

            while isinstance(attr_node, Attribute):
                name_part = attr_node.attr
                stack.append(name_part)
                attr_node = attr_node.value

            token_index = getattr(attr_node, 'token_index', None)

            if not isinstance(attr_node, Name):
                if token_index is not None:
                    self._retract(token_index)

                self._error(msg='不是合规的模块名。')

            module_name = attr_node.id

            if ' ' in module_name\
            or ' ' in module_name\
            or '　' in module_name:
                if token_index is not None:
                    self._retract(token_index)

                self._error(msg='模块名不能含有空格。')

            module_name = module_name.replace('屋头', '.')

            while stack:
                name_part = stack.pop()
                if name_part == '屋头':
                    module_name += '.'
                elif module_name.endswith('.'):
                    module_name += name_part
                else:
                    module_name += '.' + name_part
        else:
            token_index = getattr(res_node, 'token_index', None)

            if token_index is not None:
                self._retract(token_index)

            self._error(msg='不是合规的模块名。')

        asname = None
        asname_start_row, asname_start_col = self._get_start_row_col()
        ```
        (
            as_kw
            `asname_start_row, asname_start_col = self._get_start_row_col()`
            name
            ```
            asname_end_row, asname_end_col = self._get_end_row_col()
            asname = name.res.id
            ```
        )?
        ```
        if asname is None:
            asname_end_row, asname_end_col = asname_start_row, asname_start_col

        if is_from_import:
            last_dot_pos = module_name.rfind('.')

            if last_dot_pos == -1:
                self._retract(from_import_token_index)

                self._error(msg='`出来给我扎起`的模块名缺少`咧`。')

            last_part_name = module_name[last_dot_pos + 1:]

            module_name = module_name[:last_dot_pos]

            if not module_name or module_name.endswith('.'):
                module_name += '.'

            res_node = ImportFrom(
                module=module_name,
                names=[
                    alias(
                        name=last_part_name,
                        asname=asname,
                        lineno=asname_start_row,
                        col_offset=asname_start_col,
                        end_lineno=asname_end_row,
                        end_col_offset=asname_end_col,
                    )
                ],
                level=0,
                lineno=start_row,
                col_offset=start_col,
                end_lineno=end_row,
                end_col_offset=end_col,
            )
        else:
            res_node = Import(
                names=[
                    alias(
                        name=module_name,
                        asname=asname,
                        lineno=asname_start_row,
                        col_offset=asname_start_col,
                        end_lineno=asname_end_row,
                        end_col_offset=asname_end_col,
                    )
                ],
                lineno=start_row,
                col_offset=start_col,
                end_lineno=end_row,
                end_col_offset=end_col,
            )
        ```
        |
        `op_start_row, op_start_col = self._get_start_row_col()`
        (
            add_assign_op
            `op_class = Add`
            |
            subtract_assign_op
            `op_class = Sub`
            |
            multiply_assign_op
            `op_class = Mult`
            |
            divide_assign_op
            `op_class = Div`
            |
            floor_divide_assign_op
            `op_class = FloorDiv`
            |
            modulo_assign_op
            `op_class = Mod`
            |
            power_assign_op
            `op_class = Pow`
            |
            bit_and_assign_op
            `op_class = BitAnd`
            |
            bit_or_assign_op
            `op_class = BitOr`
            |
            bit_xor_assign_op
            `op_class = BitXor`
            |
            bit_invert_assign_op
            `op_class = Invert`
            |
            bit_left_shift_assign_op
            `op_class = LShift`
            |
            bit_right_shift_assign_op
            `op_class = RShift`
        )
        `op_end_row, op_end_col = self._get_end_row_col()`
        expr
        ```
        end_row, end_col = self._get_end_row_col()
        op_node = op_class(
            lineno=op_start_row,
            col_offset=op_start_col,
            end_lineno=op_end_row,
            end_col_offset=op_end_col,
        )
        self._set_store_ctx(res_node)
        res_node = AugAssign(
            target=res_node,
            op=op_node,
            value=expr.res,
            lineno=start_row,
            col_offset=start_col,
            end_lineno=end_row,
            end_col_offset=end_col,
        )
        ```
    )?
    `ctx.res = res_node`


expr:
    ```
    token_index = self._get_token_index()
    start_row, start_col = self._get_start_row_col()
    ```
    cond_exprs_list
    ```
    nodes = cond_exprs_list.res.nodes
    if len(nodes) == 1 and not cond_exprs_list.res.has_comma:
        ctx.res = nodes[0]
    else:
        end_row, end_col = self._get_end_row_col()

        ctx.res = Tuple(
            elts=nodes,
            ctx=Load(),
            lineno=start_row,
            col_offset=start_col,
            end_lineno=end_row,
            end_col_offset=end_col,
        )

    ctx.res.token_index = token_index
    ```


cond_exprs_list:
    ```
    # Used in child `cond_exprs_list_item`.
    ctx.res = AttrDict()
    ctx.res.nodes = []
    ctx.res.has_comma = False
    ```
    cond_exprs_list_item


cond_exprs_list_item:
    ```
    # Used in child `cond_exprs_list_item`.
    ctx.res = ctx.par.res
    ```
    cond_expr
    `ctx.res.nodes.append(cond_expr.res)`
    (
        comma_hz
        `ctx.res.has_comma = True`
        (
            cond_exprs_list_item
        )?
    )?


expr_no_comp:
    ```
    nodes = []
    token_index = self._get_token_index()
    start_row, start_col = self._get_start_row_col()
    ```
    cond_exprs_no_comp_list
    ```
    nodes = cond_exprs_no_comp_list.res.nodes
    if len(nodes) == 1 and not cond_exprs_no_comp_list.res.has_comma:
        ctx.res = nodes[0]
    else:
        end_row, end_col = self._get_end_row_col()

        ctx.res = Tuple(
            elts=nodes,
            ctx=Load(),
            lineno=start_row,
            col_offset=start_col,
            end_lineno=end_row,
            end_col_offset=end_col,
        )

    ctx.res.token_index = token_index
    ```


cond_exprs_no_comp_list:
    ```
    # Used in child `cond_exprs_no_comp_list_item`.
    ctx.res = AttrDict()
    ctx.res.nodes = []
    ctx.res.has_comma = False
    ```
    cond_exprs_no_comp_list_item


cond_exprs_no_comp_list_item:
    ```
    # Used in child `cond_exprs_no_comp_list_item`.
    ctx.res = ctx.par.res
    ```
    cond_expr_no_comp
    `ctx.res.nodes.append(cond_expr_no_comp.res)`
    (
        comma_hz
        `ctx.res.has_comma = True`
        (
            cond_exprs_no_comp_list_item
        )?
    )?


cond_expr:
    `start_row, start_col = self._get_start_row_col()`
    comp_expr
    ```
    test_expr = comp_expr.res
    lhs_expr = None
    ```
    (
        question_mark_hz
        comp_expr
        (
            question_mark_hz
            ```
            self._retract()
            self._error(msg='连续的条件表达式请加括号。')
            ```
        )?
        `lhs_expr = comp_expr.res`
        colon_hz
        comp_expr
        (
            question_mark_hz
            ```
            self._retract()
            self._error(msg='连续的条件表达式请加括号。')
            ```
        )?
        `rhs_expr = comp_expr.res`
    )?
    ```
    if lhs_expr is None:
        ctx.res = test_expr
    else:
        end_row, end_col = self._get_end_row_col()

        ctx.res = IfExp(
            test=test_expr,
            body=lhs_expr,
            orelse=rhs_expr,
            lineno=start_row,
            col_offset=start_col,
            end_lineno=end_row,
            end_col_offset=end_col,
        )
    ```


cond_expr_no_comp:
    `start_row, start_col = self._get_start_row_col()`
    or_expr
    ```
    test_expr = or_expr.res
    lhs_expr = None
    ```
    (
        question_mark_hz
        or_expr
        (
            question_mark_hz
            ```
            self._retract()
            self._error(msg='连续的条件表达式请加括号。')
            ```
        )?
        `lhs_expr = or_expr.res`
        colon_hz
        or_expr
        (
            question_mark_hz
            ```
            self._retract()
            self._error(msg='连续的条件表达式请加括号。')
            ```
        )?
        `rhs_expr = or_expr.res`
    )?
    ```
    if lhs_expr is None:
        ctx.res = test_expr
    else:
        end_row, end_col = self._get_end_row_col()

        ctx.res = IfExp(
            test=test_expr,
            body=lhs_expr,
            orelse=rhs_expr,
            lineno=start_row,
            col_offset=start_col,
            end_lineno=end_row,
            end_col_offset=end_col,
        )
    ```


comp_expr:
    `start_row, start_col = self._get_start_row_col()`
    or_expr
    ```
    ctx.res = or_expr.res
    ctx.start_row = start_row
    ctx.start_col = start_col
    ```
    comp_trailer*


comp_trailer:
    ```
    iter_node = ctx.par.res
    start_row = ctx.par.start_row
    start_col = ctx.par.start_col
    comp_infos = []
    ```
    (
        comp_item_as_name_kw
        `is_async = False`
        |
        async_comp_item_as_name_kw
        `is_async = True`
    )
    `names_start_row, names_start_col = self._get_start_row_col()`
    comp_names_list
    ```
    names_end_row, names_end_col = self._get_end_row_col()
    if_expr = None
    ```
    (
        comp_if_kw
        expr
        `if_expr = expr.res`
    )?
    ```
    comp_info = dict(
        is_async=is_async,
        names_start_row=names_start_row,
        names_start_col=names_start_col,
        names_end_row=names_end_row,
        names_end_col=names_end_col,
        names_list=comp_names_list.res,
        if_expr=if_expr,
        iter_node=iter_node,
    )
    comp_infos.append(comp_info)
    ```
    (
        comp_then_kw
        expr_no_comp
        `iter_node = expr_no_comp.res`
        (
            comp_item_as_name_kw
            `is_async = False`
            |
            async_comp_item_as_name_kw
            `is_async = True`
        )
        `names_start_row, names_start_col = self._get_start_row_col()`
        comp_names_list
        ```
        names_end_row, names_end_col = self._get_end_row_col()
        if_expr = None
        ```
        (
            comp_if_kw
            expr
            `if_expr = expr.res`
        )?
        ```
        comp_info = dict(
            is_async=is_async,
            names_start_row=names_start_row,
            names_start_col=names_start_col,
            names_end_row=names_end_row,
            names_end_col=names_end_col,
            names_list=comp_names_list.res,
            if_expr=if_expr,
            iter_node=iter_node,
        )
        comp_infos.append(comp_info)
        ```
    )*
    (
        listcomp_generate_kw
        `is_generator = False`
        |
        generator_generate_kw
        `is_generator = True`
    )
    expr
    ```
    end_row, end_col = self._get_end_row_col()

    comp_nodes = []

    for comp_info in comp_infos:
        is_async = comp_info['is_async']
        names_start_row = comp_info['names_start_row']
        names_start_col = comp_info['names_start_col']
        names_end_row = comp_info['names_end_row']
        names_end_col = comp_info['names_end_col']
        names_list = comp_info['names_list']
        if_expr = comp_info['if_expr']
        iter_node = comp_info['iter_node']

        name_nodes = names_list

        name_nodes_count = len(name_nodes)

        for name_node in name_nodes:
            name_node.ctx = Store()

        if name_nodes_count == 1:
            comp_vars = name_nodes[0]
        else:
            comp_vars = Tuple(
                elts=name_nodes,
                ctx=Store(),
                lineno=names_start_row,
                col_offset=names_start_col,
                end_lineno=names_end_row,
                end_col_offset=names_end_col,
            )

        if if_expr is None:
            comp_node_end_row = name_nodes[-1].end_lineno
            comp_node_end_col = name_nodes[-1].end_col_offset
        else:
            comp_node_end_row = if_expr.end_lineno
            comp_node_end_col = if_expr.end_col_offset

        comp_node = comprehension(
            target=comp_vars,
            iter=iter_node,
            ifs=[] if if_expr is None else [if_expr],
            is_async=is_async,
            lineno=iter_node.lineno,
            col_offset=iter_node.col_offset,
            end_lineno=comp_node_end_row,
            end_col_offset=comp_node_end_col,
        )

        comp_nodes.append(comp_node)

    node_class = GeneratorExp if is_generator else ListComp

    ctx.par.res = node_class(
        elt=expr.res,
        generators=comp_nodes,
        lineno=start_row,
        col_offset=start_col,
        end_lineno=end_row,
        end_col_offset=end_col,
    )
    ```


comp_names_list:
    ```
    # Used in child `comp_names_list_item`.
    ctx.res = []
    ```
    comp_names_list_item


comp_names_list_item:
    ```
    # Used in child `comp_names_list_item`.
    ctx.res = ctx.par.res
    ```
    name
    ```
    ctx.res.append(name.res)
    ```
    (
        pause_hz
        comp_names_list_item
    )?


or_expr:
    ```
    results = []
    token_index = self._get_token_index()
    start_row, start_col = self._get_start_row_col()
    first_op_pos = None
    ```
    and_expr
    `results.append(and_expr.res)`
    (
        ```
        if first_op_pos is None:
            op_start_row, op_start_col = self._get_start_row_col()
        ```
        or_op
        ```
        if first_op_pos is None:
            op_end_row, op_end_col = self._get_end_row_col()

            first_op_pos = dict(
                lineno=op_start_row,
                col_offset=op_start_col,
                end_lineno=op_end_row,
                end_col_offset=op_end_col,
            )
        ```
        and_expr
        `results.append(and_expr.res)`
    )*
    ```
    if len(results) == 1:
        ctx.res = results[0]
    else:
        end_row, end_col = self._get_end_row_col()

        ctx.res = BoolOp(
            op=Or(**first_op_pos),
            values=results,
            lineno=start_row,
            col_offset=start_col,
            end_lineno=end_row,
            end_col_offset=end_col,
        )

    ctx.res.token_index = token_index
    ```


and_expr:
    ```
    results = []
    token_index = self._get_token_index()
    start_row, start_col = self._get_start_row_col()
    first_op_pos = None
    ```
    not_expr
    `results.append(not_expr.res)`
    (
        ```
        if first_op_pos is None:
            op_start_row, op_start_col = self._get_start_row_col()
        ```
        and_op
        ```
        if first_op_pos is None:
            op_end_row, op_end_col = self._get_end_row_col()

            first_op_pos = dict(
                lineno=op_start_row,
                col_offset=op_start_col,
                end_lineno=op_end_row,
                end_col_offset=op_end_col,
            )
        ```
        not_expr
        `results.append(not_expr.res)`
    )*
    ```
    if len(results) == 1:
        ctx.res = results[0]
    else:
        end_row, end_col = self._get_end_row_col()

        ctx.res = BoolOp(
            op=And(**first_op_pos),
            values=results,
            lineno=start_row,
            col_offset=start_col,
            end_lineno=end_row,
            end_col_offset=end_col,
        )

    ctx.res.token_index = token_index
    ```


not_expr:
    ```
    token_index = self._get_token_index()
    start_row, start_col = self._get_start_row_col()
    ```
    (
    `op_start_row, op_start_col = self._get_start_row_col()`
    not_op
    `op_end_row, op_end_col = self._get_end_row_col()`
    not_expr
    ```
    end_row, end_col = self._get_end_row_col()
    ctx.res = UnaryOp(
        op=Not(
            lineno=op_start_row,
            col_offset=op_start_col,
            end_lineno=op_end_row,
            end_col_offset=op_end_col,
        ),
        operand=not_expr.res,
        lineno=start_row,
        col_offset=start_col,
        end_lineno=end_row,
        end_col_offset=end_col,
    )
    ```
    |
    compare_expr
    `ctx.res = compare_expr.res`
    )
    `ctx.res.token_index = token_index`


compare_expr:
    ```
    token_index = self._get_token_index()
    start_row, start_col = self._get_start_row_col()
    ```
    arrow_expr
    ```
    left_expr = arrow_expr.res
    ops = []
    comparators = []
    ```
    (
        `op_start_row, op_start_col = self._get_row_col()`
        (
        is_op
        `op_class = Is`
        |
        isnot_op
        `op_class = IsNot`
        |
        equal_op
        `op_class = Eq`
        |
        not_equal_op
        `op_class = NotEq`
        |
        lt_op
        `op_class = Lt`
        |
        le_op
        `op_class = LtE`
        |
        gt_op
        `op_class = Gt`
        |
        ge_op
        `op_class = GtE`
        |
        in_op
        `op_class = In`
        |
        not_in_op
        `op_class = NotIn`
        )
        ```
        op_end_row, op_end_col = self._get_end_row_col()

        op_node = op_class(
            lineno=op_start_row,
            col_offset=op_start_col,
            end_lineno=op_end_row,
            end_col_offset=op_end_col,
        )

        ops.append(op_node)
        ```
        arrow_expr
        `comparators.append(arrow_expr.res)`
    )*
    ```
    if not ops:
        ctx.res = left_expr
    else:
        end_row, end_col = self._get_end_row_col()
        ctx.res = Compare(
            left=left_expr,
            ops=ops,
            comparators=comparators,
            lineno=start_row,
            col_offset=start_col,
            end_lineno=end_row,
            end_col_offset=end_col,
        )

    ctx.res.token_index = token_index
    ```


arrow_expr:
    ```
    token_index = self._get_token_index()
    ```
    bitwise_expr
    `res_expr = bitwise_expr.res`
    `rhs_infos = []`
    (
        arrow_op
        `rhs_token_index = self._get_token_index()`
        bitwise_expr
        `rhs_infos.append((rhs_token_index, bitwise_expr.res))`
    )*
    ```
    if len(rhs_infos) == 0:
        ctx.res = res_expr
    else:
        for rhs_token_index, rhs_expr in rhs_infos:
            if not isinstance(rhs_expr, Call):
                self._retract(rhs_token_index)

                self._error(msg='`接倒起`的右手边不是函数调用。')

            for arg_index, arg in enumerate(rhs_expr.args):
                if isinstance(arg, Name) and arg.id == '…':
                    break
            else:
                self._retract(rhs_token_index)

                self._error(msg='`接倒起`的右手边函数调用参数缺占位符`…`。')

            rhs_expr.args[arg_index:arg_index+1] = [res_expr]

            res_expr = rhs_expr

        ctx.res = res_expr

    ctx.res.token_index = token_index
    ```


bitwise_expr:
    ```
    token_index = self._get_token_index()
    start_row, start_col = self._get_start_row_col()
    ```
    add_substruct_expr
    `res_expr = add_substruct_expr.res`
    (
        `op_start_row, op_start_col = self._get_start_row_col()`
        (
            bit_and_op
            `op_class = BitAnd`
            |
            bit_or_op
            `op_class = BitOr`
            |
            bit_xor_op
            `op_class = BitXor`
            |
            bit_left_shift_op
            `op_class = LShift`
            |
            bit_right_shift_op
            `op_class = RShift`
        )
        ```
        end_row, end_col = self._get_end_row_col()
        op_node = op_class(
            lineno=op_start_row,
            col_offset=op_start_col,
            end_lineno=end_row,
            end_col_offset=end_col,
        )
        ```
        add_substruct_expr
        ```
        end_row, end_col = self._get_end_row_col()
        res_expr = BinOp(
            left=res_expr,
            op=op_node,
            right=add_substruct_expr.res,
            lineno=start_row,
            col_offset=start_col,
            end_lineno=end_row,
            end_col_offset=end_col,
        )
        ```
    )*
    ```
    ctx.res = res_expr
    ctx.res.token_index = token_index
    ```


add_substruct_expr:
    ```
    token_index = self._get_token_index()
    start_row, start_col = self._get_start_row_col()
    ```
    multiply_divide_expr
    `res_expr = multiply_divide_expr.res`
    (
        `op_start_row, op_start_col = self._get_start_row_col()`
        (
        add_op
        `op_class = Add`
        |
        subtract_op
        `op_class = Sub`
        )
        ```
        op_end_row, op_end_col = self._get_end_row_col()
        op_node = op_class(
            lineno=op_start_row,
            col_offset=op_start_col,
            end_lineno=op_end_row,
            end_col_offset=op_end_col,
        )
        ```
        multiply_divide_expr
        ```
        end_row, end_col = self._get_end_row_col()
        res_expr = BinOp(
            left=res_expr,
            op=op_node,
            right=multiply_divide_expr.res,
            lineno=start_row,
            col_offset=start_col,
            end_lineno=end_row,
            end_col_offset=end_col,
        )
        ```
    )*
    ```
    ctx.res = res_expr
    ctx.res.token_index = token_index
    ```


multiply_divide_expr:
    ```
    token_index = self._get_token_index()
    start_row, start_col = self._get_start_row_col()
    ```
    power_expr
    `res_expr = power_expr.res`
    (
        `op_start_row, op_start_col = self._get_start_row_col()`
        (
        multiply_op
        `op_class = Mult`
        |
        divide_op
        `op_class = Div`
        |
        floor_divide_op
        `op_class = FloorDiv`
        |
        modulo_op
        `op_class = Mod`
        )
        ```
        op_end_row, op_end_col = self._get_end_row_col()
        op_node = op_class(
            lineno=op_start_row,
            col_offset=op_start_col,
            end_lineno=op_end_row,
            end_col_offset=op_end_col,
        )
        ```
        power_expr
        ```
        end_row, end_col = self._get_end_row_col()

        res_expr = BinOp(
            left=res_expr,
            op=op_node,
            right=power_expr.res,
            lineno=start_row,
            col_offset=start_col,
            end_lineno=end_row,
            end_col_offset=end_col,
        )
        ```
    )*
    ```
    ctx.res = res_expr
    ctx.res.token_index = token_index
    ```


power_expr:
    ```
    token_index = self._get_token_index()
    stack = []
    ```
    trailer_expr
    `stack.append((trailer_expr.res, None, None, None, None))`
    (
        `op_start_row, op_start_col = self._get_start_row_col()`
        power_op
        `op_end_row, op_end_col = self._get_end_row_col()`
        trailer_expr
        ```
        stack.append(
            (
                trailer_expr.res,
                op_start_row,
                op_start_col,
                op_end_row,
                op_end_col,
            )
        )
        ```
    )*
    ```
    if len(stack) == 1:
        ctx.res = stack[0][0]
    else:
        rhs_node, op_start_row, op_start_col, op_end_row, op_end_col\
            = stack.pop()

        while stack:
            lhs_node, op_start_row2, op_start_col2, op_end_row2, op_end_col2\
                = stack.pop()

            rhs_node = BinOp(
                left=lhs_node,
                op=Pow(
                    lineno=op_start_row,
                    col_offset=op_start_col,
                    end_lineno=op_end_row,
                    end_col_offset=op_end_col,
                ),
                right=rhs_node,
                lineno=lhs_node.lineno,
                col_offset=lhs_node.col_offset,
                end_lineno=rhs_node.end_lineno,
                end_col_offset=rhs_node.end_col_offset,
            )

            op_start_row = op_start_row2
            op_start_col = op_start_col2
            op_end_row = op_end_row2
            op_end_col = op_end_col2

        ctx.res = rhs_node

    ctx.res.token_index = token_index
    ```


trailer_expr:
    ```
    token_index = self._get_token_index()
    op_node = None
    ```
    (
        `op_start_row, op_start_col = self._get_start_row_col()`
        (
        unary_subtract_op
        `op_class = USub`
        |
        bit_invert_op
        `op_class = Invert`
        )
        ```
        op_end_row, op_end_col = self._get_end_row_col()
        op_node = op_class(
            lineno=op_start_row,
            col_offset=op_start_col,
            end_lineno=op_end_row,
            end_col_offset=op_end_col,
        )
        ```
    )?
    atom_expr
    ```
    atom_node = atom_expr.res

    if op_node is not None:
        ctx.res = UnaryOp(
            op=op_node,
            operand=atom_node,
            lineno=op_start_row,
            col_offset=op_start_col,
            end_lineno=atom_node.end_lineno,
            end_col_offset=atom_node.end_col_offset,
        )
    else:
        ctx.res = atom_node

    ctx.res.token_index = token_index
    ```
    # `ctx.res` will be changed inside `atom_trailer`.
    atom_trailer*


atom_expr:
    (
    none
    `ctx.res = none.res`
    |
    boolean
    `ctx.res = boolean.res`
    |
    number
    `ctx.res = number.res`
    |
    string
    `ctx.res = string.res`
    |
    name
    `ctx.res = name.res`
    |
    container
    `ctx.res = container.res`
    |
    parentheses_expr
    `ctx.res = parentheses_expr.res`
    )


container:
    `start_row, start_col = self._get_start_row_col()`
    list_kw
    ```
    end_row, end_col = self._get_end_row_col()
    ctx.res = List(
        elts=[],
        ctx=Load(),
        lineno=start_row,
        col_offset=start_col,
        end_lineno=end_row,
        end_col_offset=end_col,
    )
    ```
    |
    `start_row, start_col = self._get_start_row_col()`
    list_with_kw
    args_list
    ```
    end_row, end_col = self._get_end_row_col()
    ctx.res = List(
        elts=args_list.res.args,
        ctx=Load(),
        lineno=start_row,
        col_offset=start_col,
        end_lineno=end_row,
        end_col_offset=end_col,
    )
    ```
    |
    `start_row, start_col = self._get_start_row_col()`
    tuple_kw
    ```
    end_row, end_col = self._get_end_row_col()
    ctx.res = Tuple(
        elts=[],
        ctx=Load(),
        lineno=start_row,
        col_offset=start_col,
        end_lineno=end_row,
        end_col_offset=end_col,
    )
    ```
    |
    `start_row, start_col = self._get_start_row_col()`
    tuple_with_kw
    args_list
    ```
    end_row, end_col = self._get_end_row_col()
    ctx.res = Tuple(
        elts=args_list.res.args,
        ctx=Load(),
        lineno=start_row,
        col_offset=start_col,
        end_lineno=end_row,
        end_col_offset=end_col,
    )
    ```
    |
    `start_row, start_col = self._get_start_row_col()`
    dict_kw
    ```
    end_row, end_col = self._get_end_row_col()
    ctx.res = Dict(
        keys=[],
        values=[],
        lineno=start_row,
        col_offset=start_col,
        end_lineno=end_row,
        end_col_offset=end_col,
    )
    ```
    |
    `start_row, start_col = self._get_start_row_col()`
    dict_with_kw
    ```
    kw_end_row, kw_end_col = self._get_end_row_col()
    args_start_row, args_start_col = self._get_start_row_col()
    ```
    args_list
    ```
    end_row, end_col = self._get_end_row_col()
    ctx.res = Call(
        func=Name(
            id='dict',
            ctx=Load(),
            lineno=start_row,
            col_offset=start_col,
            end_lineno=kw_end_row,
            end_col_offset=kw_end_col,
        ),
        args=[
            List(
                elts=args_list.res.args,
                ctx=Load(),
                lineno=args_start_row,
                col_offset=args_start_col,
                end_lineno=end_row,
                end_col_offset=end_col,
            )
        ],
        keywords=[],
        lineno=start_row,
        col_offset=start_col,
        end_lineno=end_row,
        end_col_offset=end_col,
    )
    ```
    |
    `start_row, start_col = self._get_start_row_col()`
    set_kw
    ```
    end_row, end_col = self._get_end_row_col()
    ctx.res = Call(
        func=Name(
            id='set',
            ctx=Load(),
            lineno=start_row,
            col_offset=start_col,
            end_lineno=end_row,
            end_col_offset=end_col,
        ),
        args=[],
        keywords=[],
        lineno=start_row,
        col_offset=start_col,
        end_lineno=end_row,
        end_col_offset=end_col,
    )
    ```
    |
    `start_row, start_col = self._get_start_row_col()`
    set_with_kw
    args_list
    ```
    end_row, end_col = self._get_end_row_col()
    ctx.res = Set(
        elts=args_list.res.args,
        lineno=start_row,
        col_offset=start_col,
        end_lineno=end_row,
        end_col_offset=end_col,
    )
    ```


parentheses_expr:
    `start_row, start_col = self._get_start_row_col()`
    left_parenthesis_hz
    (
        right_parenthesis_hz
        `end_row, end_col = self._get_end_row_col()`
        ```
        ctx.res = Tuple(
            elts=[],
            ctx=Store(),
            lineno=start_row,
            col_offset=start_col,
            end_lineno=end_row,
            end_col_offset=end_col,
        )
        ```
        |
        (
            yield_expr
            `ctx.res = yield_expr.res`
            |
            expr
            `ctx.res = expr.res`
        )
        right_parenthesis_hz
    )


atom_trailer:
    ```
    token_index = self._get_token_index()
    start_row, start_col = self._get_start_row_col()
    ```
    dot_kw
    name
    ```
    end_row, end_col = self._get_end_row_col()
    par_node = ctx.par.res
    ctx.par.res = Attribute(
        value=par_node,
        attr=name.res.id,
        ctx=Load(),
        lineno=start_row,
        col_offset=start_col,
        end_lineno=end_row,
        end_col_offset=end_col,
    )
    ctx.par.res.token_index = token_index
    ```
    |
    `start_row, start_col = self._get_start_row_col()`
    global_kw
    ```
    end_row, end_col = self._get_end_row_col()
    ctx.par.res = Global(
        names=[ctx.par.res.id],
        lineno=start_row,
        col_offset=start_col,
        end_lineno=end_row,
        end_col_offset=end_col,
    )
    ```
    |
    `start_row, start_col = self._get_start_row_col()`
    nonlocal_kw
    ```
    end_row, end_col = self._get_end_row_col()
    ctx.par.res = Nonlocal(
        names=[ctx.par.res.id],
        lineno=start_row,
        col_offset=start_col,
        end_lineno=end_row,
        end_col_offset=end_col,
    )
    ```
    |
    `start_row, start_col = self._get_start_row_col()`
    args_list
    ```
    end_row, end_col = self._get_end_row_col()
    ctx.par.res = Call(
        func=ctx.par.res,
        args=args_list.res.args,
        keywords=args_list.res.kwargs,
        lineno=start_row,
        col_offset=start_col,
        end_lineno=end_row,
        end_col_offset=end_col,
    )
    ```
    |
    `start_row, start_col = self._get_start_row_col()`
    subscript_start_kw
    ```
    is_slice = False
    slice_part1 = None
    slice_part2 = None
    slice_part3 = None
    index_start_row, index_start_col = self._get_start_row_col()
    ```
    (
        expr
        `slice_part1 = expr.res`
        (
            colon_hz
            `is_slice = True`
            (
                (
                    expr
                    `slice_part2 = expr.res`
                )?
                (
                    colon_hz
                    (
                        expr
                        `slice_part3 = expr.res`
                    )?
                )?
            )?
        )?
        |
        colon_hz
        `is_slice = True`
        (
            (
                expr
                `slice_part2 = expr.res`
            )?
            (
                colon_hz
                (
                    expr
                    `slice_part3 = expr.res`
                )?
            )?
        )?
    )
    `index_end_row, index_end_col = self._get_end_row_col()`
    subscript_end_kw
    ```
    end_row, end_col = self._get_end_row_col()

    if is_slice:
        ctx.par.res = Subscript(
            value=ctx.par.res,
            slice=Slice(
                lower=slice_part1,
                upper=slice_part2,
                step=slice_part3,
                lineno=index_start_row,
                col_offset=index_start_col,
                end_lineno=index_end_row,
                end_col_offset=index_end_col,
            ),
            ctx=Load(),
            lineno=start_row,
            col_offset=start_col,
            end_lineno=end_row,
            end_col_offset=end_col,
        )
    else:
        ctx.par.res = Subscript(
            value=ctx.par.res,
            slice=Index(
                value=slice_part1,
                lineno=index_start_row,
                col_offset=index_start_col,
                end_lineno=index_end_row,
                end_col_offset=index_end_col,
            ),
            ctx=Load(),
            lineno=start_row,
            col_offset=start_col,
            end_lineno=end_row,
            end_col_offset=end_col,
        )
    ```
    |
    decorate_kw
    ```
    name_node = ctx.par.res

    if not isinstance(name_node, Name):
        token_index = getattr(name_node, 'token_index', None)

        if token_index is not None:
            self._retract(token_index)

        self._error(msg='`打整一哈`的左手边必须是名字。')

    decorator_nodes = []

    has_args = False
    ```
    (
        args_list
        `has_args = True`
    )?
    ```
    end_row, end_col = self._get_end_row_col()

    if has_args:
        decorator_node = Call(
            func=name_node,
            args=args_list.res.args,
            keywords=args_list.res.kwargs,
            lineno=name_node.lineno,
            col_offset=name_node.col_offset,
            end_lineno=end_row,
            end_col_offset=end_col,
        )

        decorator_nodes.append(decorator_node)
    else:
        decorator_nodes.append(name_node)
    ```
    (
        `has_args = False`
        name
        decorate_kw
        `name_node = name.res`
        (
            args_list
            `has_args = True`
        )?
        ```
        end_row, end_col = self._get_end_row_col()

        if has_args:
            decorator_node = Call(
                func=name_node,
                args=args_list.res.args,
                keywords=args_list.res.kwargs,
                lineno=name_node.lineno,
                col_offset=name_node.col_offset,
                end_lineno=end_row,
                end_col_offset=end_col,
            )

            decorator_nodes.append(decorator_node)
        else:
            decorator_nodes.append(name_node)
        ```
    )*
    `ctx.decorator_nodes = decorator_nodes`
    (
        func_def
        `ctx.par.res = func_def.res`
        |
        class_def
        `ctx.par.res = class_def.res`
    )
    |
    ```
    node = ctx.par.res
    start_row = ctx.par.res.lineno
    start_col = ctx.par.res.col_offset
    ```
    (
        (
            (
                trailer_prefix
                ```
                self._retract()
                self._error(msg='`嘞`是保留的关键字。')
                ```
                |
                type_trailer
                `func_name = 'type'`
                |
                len_trailer
                `func_name = 'len'`
                |
                count_trailer
                `func_name = 'len'`
                |
                abs_trailer
                `func_name = 'abs'`
                |
                min_trailer
                `func_name = 'min'`
                |
                max_trailer
                `func_name = 'max'`
                |
                bool_trailer
                `func_name = 'bool'`
                |
                int_trailer
                `func_name = 'int'`
                |
                float_trailer
                `func_name = 'float'`
                |
                str_trailer
                `func_name = 'str'`
                |
                repr_trailer
                `func_name = 'repr'`
                |
                bytes_trailer
                `func_name = 'bytes'`
                |
                bytearray_trailer
                `func_name = 'bytearray'`
                |
                chr_trailer
                `func_name = 'chr'`
                |
                ord_trailer
                `func_name = 'ord'`
                |
                hex_trailer
                `func_name = 'hex'`
                |
                oct_trailer
                `func_name = 'oct'`
                |
                bin_trailer
                `func_name = 'bin'`
                |
                sum_trailer
                `func_name = 'sum'`
                |
                any_trailer
                `func_name = 'any'`
                |
                all_trailer
                `func_name = 'all'`
                |
                list_trailer
                `func_name = 'list'`
                |
                tuple_trailer
                `func_name = 'tuple'`
                |
                dict_trailer
                `func_name = 'dict'`
                |
                set_trailer
                `func_name = 'set'`
            )
            ```
            end_row, end_col = self._get_end_row_col()
            func_name_node = Name(
                id=func_name,
                ctx=Load(),
                lineno=start_row,
                col_offset=start_col,
                end_lineno=end_row,
                end_col_offset=end_col,
            )
            node = Call(
                func=func_name_node,
                args=[node],
                keywords=[],
                lineno=start_row,
                col_offset=start_col,
                end_lineno=end_row,
                end_col_offset=end_col,
            )
            ```
        )
        |
        `op_start_row, op_start_col = self._get_start_row_col()`
        opposite_trailer
        ```
        end_row, end_col = self._get_end_row_col()
        node = UnaryOp(
            op=USub(
                lineno=op_start_row,
                col_offset=op_start_col,
                end_lineno=end_row,
                end_col_offset=end_col,
            ),
            operand=node,
            lineno=start_row,
            col_offset=start_col,
            end_lineno=end_row,
            end_col_offset=end_col,
        )
        ```
        |
        `op_start_row, op_start_col = self._get_start_row_col()`
        reciprocal_trailer
        ```
        end_row, end_col = self._get_end_row_col()
        node = BinOp(
            left=Num(
                1,
                kind=None,
                lineno=node.lineno,
                col_offset=node.col_offset,
                end_lineno=node.end_lineno,
                end_col_offset=node.end_col_offset,
            ),
            op=Div(
                lineno=op_start_row,
                col_offset=op_start_col,
                end_lineno=end_row,
                end_col_offset=end_col,
            ),
            right=node,
            lineno=start_row,
            col_offset=start_col,
            end_lineno=end_row,
            end_col_offset=end_col,
        )
        ```
        |
        `op_start_row, op_start_col = self._get_start_row_col()`
        range_trailer
        ```
        end_row, end_col = self._get_end_row_col()
        func_name_node = Name(
            id='range',
            ctx=Load(),
            lineno=op_start_row,
            col_offset=op_start_col,
            end_lineno=end_row,
            end_col_offset=end_col,
        )
        node = Call(
            func=func_name_node,
            args=node.elts if isinstance(node, Tuple) else [node],
            keywords=[],
            lineno=start_row,
            col_offset=start_col,
            end_lineno=end_row,
            end_col_offset=end_col,
        )
        ```
        |
        `op_start_row, op_start_col = self._get_start_row_col()`
        (
            format_trailer
            `attr_name = 'format'`
            |
            add_trailer
            `attr_name = 'add'`
            |
            append_trailer
            `attr_name = 'append'`
            |
            extend_trailer
            `attr_name = 'extend'`
            |
            clear_trailer
            `attr_name = 'clear'`
            |
            sort_trailer
            `attr_name = 'sort'`
        )
        `op_end_row, op_end_col = self._get_end_row_col()`
        args_list
        ```
        end_row, end_col = self._get_end_row_col()
        attr_node = Attribute(
            value=node,
            attr=attr_name,
            ctx=Load(),
            lineno=op_start_row,
            col_offset=op_start_col,
            end_lineno=op_end_row,
            end_col_offset=op_end_col,
        )
        node = Call(
            func=attr_node,
            args=args_list.res.args,
            keywords=args_list.res.kwargs,
            lineno=start_row,
            col_offset=start_col,
            end_lineno=end_row,
            end_col_offset=end_col,
        )
        ```
        |
        `op_start_row, op_start_col = self._get_start_row_col()`
        name_trailer
        `attr_name = '__name__'`
        `op_end_row, op_end_col = self._get_end_row_col()`
        ```
        end_row, end_col = self._get_end_row_col()
        node = Attribute(
            value=node,
            attr=attr_name,
            ctx=Load(),
            lineno=op_start_row,
            col_offset=op_start_col,
            end_lineno=op_end_row,
            end_col_offset=op_end_col,
        )
        ```
    )
    `ctx.par.res = node`


compound_stmt:
    if_stmt
    `ctx.res = if_stmt.res`
    |
    loop_always_stmt
    `ctx.res = loop_always_stmt.res`
    |
    loop_if_stmt
    `ctx.res = loop_if_stmt.res`
    |
    loop_until_stmt
    `ctx.res = loop_until_stmt.res`
    |
    loop_iterator_stmt
    `ctx.res = loop_iterator_stmt.res`
    |
    try_stmt
    `ctx.res = try_stmt.res`
    |
    with_stmt
    `ctx.res = with_stmt.res`
    |
    func_def
    `ctx.res = func_def.res`
    |
    class_def
    `ctx.res = class_def.res`


if_stmt:
    ```
    stack = []
    start_row, start_col = self._get_start_row_col()
    ```
    if_kw
    expr
    `test_expr = expr.res`
    block_start_kw?
    `body_start_row, body_start_col = self._get_start_row_col()`
    stmts
    ```
    end_row, end_col = self._get_end_row_col()
    if_stmts = stmts.res or [Pass(
        lineno=body_start_row,
        col_offset=body_start_col,
        end_lineno=body_start_row,
        end_col_offset=body_start_col,
    )]
    stack.append(
        (test_expr, if_stmts, start_row, start_col, end_row, end_col)
    )
    ```
    (
        `start_row, start_col = self._get_start_row_col()`
        elif_kw
        expr
        `test_expr = expr.res`
        block_start_kw?
        `body_start_row, body_start_col = self._get_start_row_col()`
        stmts
        ```
        end_row, end_col = self._get_end_row_col()
        if_stmts = stmts.res or [Pass(
            lineno=body_start_row,
            col_offset=body_start_col,
            end_lineno=body_start_row,
            end_col_offset=body_start_col,
        )]
        stack.append(
            (test_expr, if_stmts, start_row, start_col, end_row, end_col)
        )
        ```
    )*
    `else_stmts = None`
    (
        else_kw
        block_start_kw?
        `body_start_row, body_start_col = self._get_start_row_col()`
        stmts
        ```
        else_stmts = stmts.res or [Pass(
            lineno=body_start_row,
            col_offset=body_start_col,
            end_lineno=body_start_row,
            end_col_offset=body_start_col,
        )]
        ```
    )?
    block_end_kw
    ```
    if else_stmts is None:
        else_stmts = []
    while stack:
        test_expr, if_stmts, start_row, start_col, end_row, end_col\
            = stack.pop()

        else_stmts = [
            If(
                test=test_expr,
                body=if_stmts,
                orelse=else_stmts,
                lineno=start_row,
                col_offset=start_col,
                end_lineno=end_row,
                end_col_offset=end_col,
            )
        ]

    ctx.res = else_stmts[0]
    ```


loop_always_stmt:
    `start_row, start_col = self._get_start_row_col()`
    loop_always_kw
    `test_start_row, test_start_col = self._get_start_row_col()`
    block_start_kw?
    `body_start_row, body_start_col = self._get_start_row_col()`
    stmts
    `else_stmts = None`
    (
        else_kw
        `else_body_start_row, else_body_start_col = self._get_start_row_col()`
        stmts
        ```
        else_stmts = stmts.res or [Pass(
            lineno=else_body_start_row,
            col_offset=else_body_start_col,
            end_lineno=else_body_start_row,
            end_col_offset=else_body_start_col,
        )]
        ```
    )?
    block_end_kw
    ```
    end_row, end_col = self._get_end_row_col()
    ctx.res = While(
        test=NameConstant(
            value=True,
            kind=None,
            lineno=test_start_row,
            col_offset=test_start_col,
            end_lineno=test_start_row,
            end_col_offset=test_start_col,
        ),
        body=stmts.res or [Pass(
            lineno=body_start_row,
            col_offset=body_start_col,
            end_lineno=body_start_row,
            end_col_offset=body_start_col,
        )],
        orelse=[] if else_stmts is None else else_stmts,
        lineno=start_row,
        col_offset=start_col,
        end_lineno=end_row,
        end_col_offset=end_col,
    )
    ```


loop_if_stmt:
    `start_row, start_col = self._get_start_row_col()`
    loop_if_kw
    expr
    block_start_kw?
    `body_start_row, body_start_col = self._get_start_row_col()`
    stmts
    `else_stmts = None`
    (
        else_kw
        `else_body_start_row, else_body_start_col = self._get_start_row_col()`
        stmts
        `else_stmts = stmts.res or [Pass(
            lineno=else_body_start_row,
            col_offset=else_body_start_col,
            end_lineno=else_body_start_row,
            end_col_offset=else_body_start_col,
        )]`
    )?
    block_end_kw
    ```
    end_row, end_col = self._get_end_row_col()
    ctx.res = While(
        test=expr.res,
        body=stmts.res or [Pass(
            lineno=body_start_row,
            col_offset=body_start_col,
            end_lineno=body_start_row,
            end_col_offset=body_start_col,
        )],
        orelse=[] if else_stmts is None else else_stmts,
        lineno=start_row,
        col_offset=start_col,
        end_lineno=end_row,
        end_col_offset=end_col,
    )
    ```


loop_until_stmt:
    `start_row, start_col = self._get_start_row_col()`
    loop_until_kw
    expr
    block_start_kw?
    `body_start_row, body_start_col = self._get_start_row_col()`
    stmts
    `else_stmts = None`
    (
        else_kw
        `else_body_start_row, else_body_start_col = self._get_start_row_col()`
        stmts
        `else_stmts = stmts.res or [Pass(
            lineno=else_body_start_row,
            col_offset=else_body_start_col,
            end_lineno=else_body_start_row,
            end_col_offset=else_body_start_col,
        )]`
    )?
    block_end_kw
    ```
    end_row, end_col = self._get_end_row_col()
    ctx.res = While(
        test=UnaryOp(
            op=Not(
                lineno=expr.res.lineno,
                col_offset=expr.res.col_offset,
                end_lineno=expr.res.lineno,
                end_col_offset=expr.res.col_offset,
            ),
            operand=expr.res,
            lineno=expr.res.lineno,
            col_offset=expr.res.col_offset,
            end_lineno=expr.res.end_lineno,
            end_col_offset=expr.res.end_col_offset,
        ),
        body=stmts.res or [Pass(
            lineno=body_start_row,
            col_offset=body_start_col,
            end_lineno=body_start_row,
            end_col_offset=body_start_col,
        )],
        orelse=[] if else_stmts is None else else_stmts,
        lineno=start_row,
        col_offset=start_col,
        end_lineno=end_row,
        end_col_offset=end_col,
    )
    ```


loop_iterator_stmt:
    `start_row, start_col = self._get_start_row_col()`
    (
        loop_iterator_kw
        `is_async = False`
        |
        async_loop_iterator_kw
        `is_async = True`
    )
    expr
    `iterator_expr = expr.res`
    loop_iterator_item_as_name_kw
    loop_iterator_names_list
    `body_start_row, body_start_col = self._get_start_row_col()`
    stmts
    `else_stmts = None`
    (
        else_kw
        `else_body_start_row, else_body_start_col = self._get_start_row_col()`
        stmts
        `else_stmts = stmts.res or [Pass(
            lineno=else_body_start_row,
            col_offset=else_body_start_col,
            end_lineno=else_body_start_row,
            end_col_offset=else_body_start_col,
        )]`
    )?
    block_end_kw
    ```
    end_row, end_col = self._get_end_row_col()

    var_name_nodes = loop_iterator_names_list.res

    for var_name_node in var_name_nodes:
        var_name_node.ctx = Store()

    if len(var_name_nodes) == 1:
        target = var_name_nodes[0]
    else:
        target = Tuple(
            elts=var_name_nodes,
            ctx=Store(),
            lineno=var_name_nodes[0].lineno,
            col_offset=var_name_nodes[0].col_offset,
            end_lineno=var_name_nodes[-1].end_lineno,
            end_col_offset=var_name_nodes[-1].end_col_offset,
        )

    ctx.res = (AsyncFor if is_async else For)(
        target=target,
        iter=iterator_expr,
        body=stmts.res or [Pass(
            lineno=body_start_row,
            col_offset=body_start_col,
            end_lineno=body_start_row,
            end_col_offset=body_start_col,
        )],
        orelse=[] if else_stmts is None else else_stmts,
        lineno=start_row,
        col_offset=start_col,
        end_lineno=end_row,
        end_col_offset=end_col,
    )
    ```


loop_iterator_names_list:
    ```
    # Used in child `loop_iterator_names_list_item`.
    ctx.res = []
    ```
    loop_iterator_names_list_item


loop_iterator_names_list_item:
    ```
    # Used in child `loop_iterator_names_list_item`.
    ctx.res = ctx.par.res
    ```
    name
    `ctx.res.append(name.res)`
    (
        block_start_kw
        |
        pause_hz
        loop_iterator_names_list_item
    )


try_stmt:
    ```
    finally_stmts = None
    handlers = []
    start_row, start_col = self._get_start_row_col()
    ```
    try_kw
    `body_start_row, body_start_col = self._get_start_row_col()`
    stmts
    ```
    try_stmts = stmts.res or [Pass(
        lineno=body_start_row,
        col_offset=body_start_col,
        end_lineno=body_start_row,
        end_col_offset=body_start_col,
    )]
    try_stmts_post_token_index = self._get_token_index()
    ```
    (
        ```
        exc_type = None
        exc_var_name = None
        except_start_row, except_start_col = self._get_start_row_col()
        ```
        except_kw
        (
            expr
            `exc_type = expr.res`
            (
                as_kw
                name
                `exc_var_name = name.res.id`
            )?
            block_end_kw?
        )?
        `body_start_row, body_start_col = self._get_start_row_col()`
        stmts
        ```
        end_row, end_col = self._get_end_row_col()
        handlers.append(
            ExceptHandler(
                type=exc_type,
                name=exc_var_name,
                body=stmts.res or [Pass(
                    lineno=body_start_row,
                    col_offset=body_start_col,
                    end_lineno=body_start_row,
                    end_col_offset=body_start_col,
                )],
                lineno=except_start_row,
                col_offset=except_start_col,
                end_lineno=end_row,
                end_col_offset=end_col,
            )
        )
        ```
    )*
    `else_stmts = None`
    (
        else_kw
        block_start_kw?
        `body_start_row, body_start_col = self._get_start_row_col()`
        stmts
        ```
        else_stmts = stmts.res or [Pass(
            lineno=body_start_row,
            col_offset=body_start_col,
            end_lineno=body_start_row,
            end_col_offset=body_start_col,
        )]
        ```
    )?
    ```
    finally_stmts = None
    ```
    (
        finally_kw
        `body_start_row, body_start_col = self._get_start_row_col()`
        stmts
        ```
        finally_stmts = stmts.res or [Pass(
            lineno=body_start_row,
            col_offset=body_start_col,
            end_lineno=body_start_row,
            end_col_offset=body_start_col,
        )]
        ```
    )?
    block_end_kw
    ```
    if not handlers and finally_stmts is None:
        self._retract(try_stmts_post_token_index)
        self._error(msg='必须至少有一个`抓一哈`或`最后才`。\n')

    end_row, end_col = self._get_end_row_col()

    ctx.res = Try(
        body=try_stmts,
        handlers=handlers,
        orelse=[] if else_stmts is None else else_stmts,
        finalbody=[] if finally_stmts is None else finally_stmts,
        lineno=start_row,
        col_offset=start_col,
        end_lineno=end_row,
        end_col_offset=end_col,
    )
    ```


with_stmt:
    `start_row, start_col = self._get_start_row_col()`
    (
        with_kw
        `is_async = False`
        |
        async_with_kw
        `is_async = True`
    )
    with_values_list
    `body_start_row, body_start_col = self._get_start_row_col()`
    stmts
    block_end_kw
    ```
    end_row, end_col = self._get_end_row_col()
    with_items = []
    for value_expr, name_expr in with_values_list.res:
        end_expr = name_expr if name_expr is not None else value_expr
        with_item = withitem(
            context_expr=value_expr,
            optional_vars=name_expr,
            lineno=value_expr.lineno,
            col_offset=value_expr.col_offset,
            end_lineno=end_expr.end_lineno,
            end_col_offset=end_expr.end_col_offset,
        )
        with_items.append(with_item)

    ctx.res = (AsyncWith if is_async else With)(
        items=with_items,
        body=stmts.res or [Pass(
            lineno=body_start_row,
            col_offset=body_start_col,
            end_lineno=body_start_row,
            end_col_offset=body_start_col,
        )],
        lineno=start_row,
        col_offset=start_col,
        end_lineno=end_row,
        end_col_offset=end_col,
    )
    ```


with_values_list:
    ```
    # Used in child `with_values_list_item`.
    ctx.res = []
    ```
    with_values_list_item


with_values_list_item:
    ```
    # Used in child `with_values_list_item`.
    ctx.res = ctx.par.res
    ```
    expr
    `name_node = None`
    (
        as_kw
        name
        ```
        name_node = name.res
        name_node.ctx = Store()
        ```
    )?
    `ctx.res.append((expr.res, name_node))`
    (
        block_start_kw
        |
        pause_hz
        with_values_list_item
    )


func_def:
    `start_row, start_col = self._get_start_row_col()`
    (
        func_start_kw
        `is_async = False`
        |
        async_func_start_kw
        `is_async = True`
    )
    name
    `params_start_row, params_start_col = self._get_start_row_col()`
    params_list
    ```
    params_end_row, params_end_col = self._get_end_row_col()
    body_start_row, body_start_col = self._get_start_row_col()
    ```
    stmts
    func_end_kw
    ```
    end_row, end_col = self._get_end_row_col()

    decorator_list = self._get_ctx_attr(ctx.par, 'decorator_nodes')

    ctx.res = (AsyncFunctionDef if is_async else FunctionDef)(
        name=name.res.id,
        args=arguments(
            args=params_list.res.args,
            vararg=params_list.res.collect_args_node,
            posonlyargs=[],
            kwonlyargs=[],
            kw_defaults=[],
            kwarg=params_list.res.collect_kwargs_node,
            defaults=params_list.res.defaults,
            lineno=params_start_row,
            col_offset=params_start_col,
            end_lineno=params_end_row,
            end_col_offset=params_end_col,
        ),
        body=stmts.res or [Pass(
            lineno=body_start_row,
            col_offset=body_start_col,
            end_lineno=body_start_row,
            end_col_offset=body_start_col,
        )],
        decorator_list=[] if decorator_list is None else decorator_list,
        returns=None,
        lineno=start_row,
        col_offset=start_col,
        end_lineno=end_row,
        end_col_offset=end_col,
    )
    ```


params_list:
    ```
    # Used in child `params_list_item`.
    ctx.res = AttrDict()
    ctx.res.args = []
    ctx.res.kwargs = []
    ctx.res.defaults = []
    ctx.res.collect_args_node = None
    ctx.res.collect_kwargs_node = None
    ```
    left_parenthesis_hz
    (
        right_parenthesis_hz
        |
        params_list_item
    )


params_list_item:
    ```
    # Used in child `params_list_item`
    ctx.res = ctx.par.res
    collect_mode = None
    start_row, start_col = self._get_start_row_col()
    ```
    (
        collect_args_kw
        ```
        if self._get_ctx_attr(ctx.par, 'is_class_def'):
            self._retract()
            self._error(msg='`名堂`不能用`收拢`参数。')

        if ctx.res.collect_args_node is not None:
            self._retract()
            self._error(msg='`收拢`不能用第二次。')

        if ctx.res.collect_kwargs_node is not None:
            self._retract()
            self._error(msg='`收拢`不能在`收拢来`之后。')

        collect_mode = 1
        ```
        |
        collect_kwargs_kw
        ```
        if self._get_ctx_attr(ctx.par, 'is_class_def'):
            self._retract()
            self._error(msg='`名堂`不能用`收拢来`参数。')

        if ctx.res.collect_kwargs_node is not None:
            self._retract()
            self._error(msg='`收拢来`不能用第二次。')

        collect_mode = 2
        ```
    )?
    name
    ```
    if not collect_mode and ctx.res.collect_args_node is not None:
        self._retract()
        self._error(msg='普通参数不能出现在`收拢`之后。')

    if not collect_mode and ctx.res.collect_kwargs_node is not None:
        self._retract()
        self._error(msg='普通参数不能出现在`收拢来`之后。')

    has_default = False
    ```
    (
        assign_op
        ```
        if collect_mode == 1:
            self._retract()
            self._error(msg='`收拢`参数不能有默认值。')
        elif collect_mode == 2:
            self._retract()
            self._error(msg='`收拢来`参数不能有默认值。')
        ```
        cond_expr
        ```
        has_default = True
        ctx.res.defaults.append(cond_expr.res)
        ```
    )?
    ```
    end_row, end_col = self._get_end_row_col()

    if collect_mode == 1:
        node = arg(
            arg=name.res.id,
            annotation=None,
            lineno=start_row,
            col_offset=start_col,
            end_lineno=end_row,
            end_col_offset=end_col,
        )
        ctx.res.collect_args_node = node
    elif collect_mode == 2:
        node = arg(
            arg=name.res.id,
            annotation=None,
            lineno=start_row,
            col_offset=start_col,
            end_lineno=end_row,
            end_col_offset=end_col,
        )
        ctx.res.collect_kwargs_node = node
    else:
        if not has_default and ctx.res.defaults:
            self._retract()
            self._error(msg='无默认值参数不能出现在有默认值参数之后。')

        ctx.res.args.append(
            arg(
                arg=name.res.id,
                annotation=None,
                lineno=start_row,
                col_offset=start_col,
                end_lineno=end_row,
                end_col_offset=end_col,
            )
        )
    ```
    (
        right_parenthesis_hz
        |
        comma_hz
        (
            right_parenthesis_hz
            |
            params_list_item
        )
    )


class_def:
    `start_row, start_col = self._get_start_row_col()`
    class_start_kw
    name
    `ctx.is_class_def = True`
    params_list
    block_start_kw?
    `body_start_row, body_start_col = self._get_start_row_col()`
    stmts
    class_end_kw
    ```
    end_row, end_col = self._get_end_row_col()
    kwd_args_count = len(params_list.res.defaults)
    if kwd_args_count == 0:
        pos_args = params_list.res.args
        kwd_args = []
    else:
        pos_args = params_list.res.args[:-kwd_args_count]
        kwd_args = params_list.res.args[-kwd_args_count:]
    base_name_nodes = [
        Name(
            id=pos_arg.arg,
            ctx=Load(),
            lineno=pos_arg.lineno,
            col_offset=pos_arg.col_offset,
            end_lineno=pos_arg.end_lineno,
            end_col_offset=pos_arg.end_col_offset,
        ) for pos_arg in pos_args
    ]
    keywords = [
        keyword(
            arg=kwd_arg.arg,
            value=params_list.res.defaults[i],
            lineno=kwd_arg.lineno,
            col_offset=kwd_arg.col_offset,
            end_lineno=kwd_arg.end_lineno,
            end_col_offset=kwd_arg.end_col_offset,
        ) for i, kwd_arg in enumerate(kwd_args)
    ]
    decorator_list = self._get_ctx_attr(ctx.par, 'decorator_nodes')
    ctx.res = ClassDef(
        name=name.res.id,
        bases=base_name_nodes,
        keywords=keywords,
        body=stmts.res or [Pass(
            lineno=body_start_row,
            col_offset=body_start_col,
            end_lineno=body_start_row,
            end_col_offset=body_start_col,
        )],
        decorator_list=[] if decorator_list is None else decorator_list,
        lineno=start_row,
        col_offset=start_col,
        end_lineno=end_row,
        end_col_offset=end_col,
    )
    ```
